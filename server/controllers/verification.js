const bcrypt = require('bcrypt');
const uuid = require('uuid/v4');
const addDays = require('date-fns/add_days');
const isAfter = require('date-fns/is_after');
const format = require('date-fns/format');
const mailer = require('nodemailer');

const db = require('../database');
const User = require('../models/User');

const constants = require('../modules/constants');

const {
  MalformedRequestError,
  UnauthorizedError,
  ResourceNotFoundError,
} = require('../modules/errors');

// TODO Should make an ORM model for verification tokens.
const verification = {
  /**
   * Creates a token that the user can use to verify their account, given the
   * ID of the user to be verified. Then, sends an email with a link that the
   * user can use to claim their account.
   */
  generateVerificationToken(req, res, next) {
    if (!req.body.pid) {
      throw new MalformedRequestError('PID of user to verify is required.');
    }

    // The id is used for looking up the hashed verification token.
    const tokenID = uuid();
    const token = uuid();

    // Checks that an unverified account has been made given the PID.
    const findUserQuery = 'SELECT id, email, valid from users where pid = ?';
    db.knex.raw(findUserQuery, [req.body.pid])
      // Finds the email that corresponds to PID in request body. This is done
      // first to avoid an expensive token hash if the PID can't be found.
      .then((result) => {
        if (result[0].length <= 0) {
          throw new ResourceNotFoundError(`Couldn\'t find an account with PID ${req.body.pid}.`);
        }

        const unverifiedUser = result[0][0];

        if (unverifiedUser.valid) {
          throw new UnauthorizedError(`Account with PID ${req.body.pid} has already been claimed.`);
        }

        return [unverifiedUser.id, unverifiedUser.email];
      })

      // Hashes the verification token.
      .then(([id, email])=> Promise.all([id, email, bcrypt.hash(token, constants.SALT_ROUNDS)]))

      // Creates the verification token given its ID, hash, user PID.
      .then(([id, email, hash]) => {
        // TODO Extend CRUD methods in a Bookshelf base class â€“ otherwise simple
        // CRUD queries via an ORM become too verbose.
        const createTokenQuery = `
          REPLACE INTO verification_tokens (id, token, pid, expiration) VALUES (?, ?, ?, ?);
        `;

        // Verification token expires a day from now.
        const expiration = format(addDays(new Date(), 1), constants.DATABASE_DATE_FORMAT);

        return Promise.all([
          id, email, db.knex.raw(createTokenQuery, [tokenID, hash, req.body.pid, expiration]),
        ]);
      })

      // Sends an email containing a link with which the user can claim their
      // account.
      .then(([id, email]) => {
        const transporter = mailer.createTransport(constants.EMAIL_TRANSPORT_CONFIG);
        const verificationLink = `${process.env.CLIENT_ADDRESS}/claim/${id}?id=${tokenID}&token=${token}`;

        const EMAIL_TEMPLATE = `
          <h3>Thanks for coming!</h3>
          <p>
            You recently dropped by one of our events. To keep track of the points you received,
            you'll need to register an account with us using the verification link below.
          </p>
          <a href="${verificationLink}">Verify your Account</a>
        `;

        const mailOptions = {
          from: constants.EMAIL_SENDER,
          to: email,
          subject: 'UCSD Tau Beta Pi Account Verification',
          html: EMAIL_TEMPLATE,
        };

        transporter.sendMail(mailOptions, (error) => {
          if (error) {
            throw new MalformedRequestError(error.message);
          }

          res.json({ message: `Sent verification email to ${email}.` });
        });
      })
      .catch(next);
  },

  /**
   * Looks for id and token parameters generated by generateVerificationToken()
   * in the request query string to determine which user account to verify.
   */
  checkVerificationToken(req, res, next) {
    if (!req.query.id || !req.query.token) {
      throw new MalformedRequestError('Account verification requires an ID and token.');
    }

    const findVerificationTokenQuery = `
      SELECT token, pid, expiration FROM verification_tokens WHERE id = ? LIMIT 1;
    `;

    return db.knex.raw(findVerificationTokenQuery, [req.query.id])
      .then((data) => {
        if (data[0].length <= 0) {
          throw new MalformedRequestError('Verification token doesn\'t exist.');
        }

        const verificationTokenInfo = data[0][0];
        return Promise.all([
          bcrypt.compare(req.query.token, verificationTokenInfo.token),
          verificationTokenInfo,
        ]);
      })
      .then(([tokenMatches, verificationTokenInfo]) => {
        if (!tokenMatches) {
          throw new UnauthorizedError('Verification token is invalid.');
        }

        if (isAfter(new Date(), verificationTokenInfo.expiration)) {
          throw new MalformedRequestError('Verification token expired.');
        }

        return User.where('pid', verificationTokenInfo.pid).fetch({ require: true });
      })
      .then((user) => {
        req.user = user;
        return next();
      })
      .catch(next);
  },

  /** Removes verification token. */
  invalidateVerificationToken(req, res, next) {
    if (!req.query.id || !req.query.token) {
      throw new MalformedRequestError('No token to invalidate.');
    }

    const deleteVerificationTokenQuery = 'DELETE FROM verification_tokens WHERE id = ? LIMIT 1;';
    return db.knex.raw(deleteVerificationTokenQuery, [req.query.id])
      .then(() => next())
      .catch(next);
  },
};

module.exports = verification;
