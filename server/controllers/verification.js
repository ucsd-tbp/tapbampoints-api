const bcrypt = require('bcrypt');
const uuid = require('uuid/v4');
const addDays = require('date-fns/add_days');
const isAfter = require('date-fns/is_after');
const format = require('date-fns/format');
const mailer = require('nodemailer');

const db = require('../database');
const User = require('../models/User');

const constants = require('../modules/constants');

// TODO Should make an ORM model for verification tokens.
const verification = {
  /**
   * Creates a token that the user can use to verify their account, given the
   * ID of the user to be verified. Then, sends an email with a link that the
   * user can use to claim their account.
   */
  generateVerificationToken(req, res) {
    if (!req.body.pid) {
      return res.status(400).json({ message: 'PID of user to verify is required.' });
    }

    // The id is used for looking up the hashed verification token.
    const id = uuid();
    const token = uuid();

    // Checks that an unverified account has been made given the PID.
    const findUserQuery = 'SELECT email, valid from users where pid = ?';
    db.knex.raw(findUserQuery, [req.body.pid])
      // Finds the email that corresponds to PID in request body. This is done
      // first to avoid an expensive token hash if the PID can't be found.
      .then((result) => {
        if (result[0].length <= 0) {
          return Promise.reject(new Error(`Couldn\'t find an account with PID ${req.body.pid}.`));
        }

        if (result[0][0].valid) {
          return Promise.reject(
            new Error(`Account with PID ${req.body.pid} has already been claimed.`)
          );
        }

        return result[0][0].email;
      })

      // Hashes the verification token.
      .then(email => Promise.all([email, bcrypt.hash(token, constants.SALT_ROUNDS)]))

      // Creates the verification token given its ID, hash, user PID.
      .then(([email, hash]) => {
        // TODO Extend CRUD methods in a Bookshelf base class â€“ otherwise simple
        // CRUD queries via an ORM become too verbose.
        const createTokenQuery = `
          REPLACE INTO verification_tokens (id, token, pid, expiration) VALUES (?, ?, ?, ?);
        `;

        // Verification token expires a day from now.
        const expiration = format(addDays(new Date(), 1), constants.DATABASE_DATE_FORMAT);

        return Promise.all([
          email, db.knex.raw(createTokenQuery, [id, hash, req.body.pid, expiration]),
        ]);
      })

      // Sends an email containing a link with which the user can claim their
      // account.
      .then(([email]) => {
        const transporter = mailer.createTransport(constants.EMAIL_TRANSPORT_CONFIG);
        const verificationLink = `${process.env.CLIENT_ADDRESS}/claim?id=${id}&token=${token}`;

        const EMAIL_TEMPLATE = `
          <h3>Thanks for coming!</h3>
          <p>
            You recently dropped by one of our events. To keep track of the points you received,
            you'll need to register an account with us using the verification link below.
          </p>
          <a href="${verificationLink}">Verify your Account</a>
        `;

        const mailOptions = {
          from: constants.EMAIL_SENDER,
          to: email,
          subject: 'UCSD Tau Beta Pi Account Verification',
          html: EMAIL_TEMPLATE,
        };

        transporter.sendMail(mailOptions, (error) => {
          if (error) return res.status(400).json({ message: error });
          res.json({ message: `Sent verification email to ${email}.` });
        });
      })
      .catch(err => res.status(400).json({ message: err.message }));
  },

  /**
   * Looks for id and token parameters generated by generateVerificationToken()
   * in the request query string to determine which user account to verify.
   */
  checkVerificationToken(req, res, next) {
    if (!req.query.id || !req.query.token) {
      return res.status(400).json({ message: 'Account verification requires an ID and token.' });
    }

    const findVerificationTokenQuery = `
      SELECT token, pid, expiration FROM verification_tokens WHERE id = ? LIMIT 1;
    `;

    return db.knex.raw(findVerificationTokenQuery, [req.query.id])
      .then((data) => {
        if (data[0].length <= 0) {
          return Promise.reject(new Error('Verification token doesn\'t exist.'));
        }

        const verificationTokenInfo = data[0][0];
        return Promise.all([
          bcrypt.compare(req.query.token, verificationTokenInfo.token),
          verificationTokenInfo,
        ]);
      })
      .then(([tokenMatches, verificationTokenInfo]) => {
        if (!tokenMatches) {
          return Promise.reject(new Error('Verification token is invalid.'));
        }

        if (isAfter(new Date(), verificationTokenInfo.expiration)) {
          return Promise.reject(new Error('Verification token expired.'));
        }

        return User.where('pid', verificationTokenInfo.pid).fetch({ require: true });
      })
      .then((user) => {
        req.user = user;
        return next();
      })
      .catch(error => res.status(400).json({ message: error.message }));
  },

  /** Removes verification token. */
  invalidateVerificationToken(req, res, next) {
    if (!req.query.id || !req.query.token) {
      return res.status(400).json({ message: 'No token to invalidate.' });
    }

    const deleteVerificationTokenQuery = 'DELETE FROM verification_tokens WHERE id = ? LIMIT 1;';
    return db.knex.raw(deleteVerificationTokenQuery, [req.query.id])
      .then(() => next())
      .catch(error => res.status(400).json({ message: error.message }));
  },
};

module.exports = verification;
